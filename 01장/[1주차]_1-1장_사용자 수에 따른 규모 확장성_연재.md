> 발표자: 정연재

---

## 1. 단일 서버 구조

1. 사용자가 도메인으로 접속  
2. **DNS 서버**가 도메인을 IP로 변환  
3. 변환된 IP로 **웹 서버**에 접근  
4. 웹 서버는 **데이터베이스**와 연결하여 응답을 생성  

---

## 2. Database 개요

웹 서버 뒤에는 보통 데이터베이스가 붙어 있습니다. 크게 두 가지 계열이 있습니다.

### 1) RDBMS
- 예: **PostgreSQL**  
- 행(Row), 열(Column) 기반  
- PostgreSQL은 JSON도 지원해서 **하이브리드**로 불리기도 함

### 2) NoSQL
- 예: Couchbase, Memcached 계열  
- 사용되는 경우
  1. 항상 빠른 건 아니지만 **super-low latency**가 필요할 때  
  2. **Denormalize** → 여러 서버에 동일 데이터 복제, 병렬 처리로 빠른 읽기  
  3. 내부 **캐시**를 활용해 자주 쓰는 쿼리 성능 ↑  
  4. **비정형 데이터(unstructured data)** 처리  
  5. JSON/XML 직렬화·역직렬화 지원  
  6. **빅데이터** 활용 시 자주 사용  

---

## 3. DB 선택 기준

### 데이터 구조
- 테이블 기반 정형 데이터 → RDBMS  
- 계층적/희소/연결성 높은 데이터 → Document/Graph DB  

### 확장성
- RDBMS: 수직(Scale Up) 또는 수평(샤딩) 확장 가능하지만 한계 있음  
- 초대규모 확장 → **Cassandra, DynamoDB**  

### 쿼리 패턴
- 단순 키 조회 → Key-Value Store  
- 복잡한 관계 탐색 → Graph DB  
- 반정형 데이터 유연 쿼리 → Document DB  

### 운영 복잡성
- RDBMS: 성숙한 생태계, 관리 쉬움  
- NoSQL: 운영 지식 필요  

### 개발자 경험
- SQL 보편성 높음, 채용/온보딩 용이  
- 팀 상황에 맞는 기술 선택  

---

## 4. Scaling 방법

### 1) Vertical Scaling (Scale Up/Down)
- **하드웨어 업그레이드** (CPU, 메모리)  
- 초기 트래픽에 적합  
- 한계: 무한 확장 불가, Failover/Redundancy 없음  

### 2) Horizontal Scaling (Scale Out/In)
- **서버 수 추가 → 클러스터 구성**  
- 일반적으로: 작은 서버로 시작 → Scale Up → Scale Out  
- 주요 이슈
  - Master-Slave 구조 (Write/Read 분리)  
  - Sharding: 데이터 분할, Re-sharding 시 셔플 필요  
  - Hotspot Key 문제(특정 유저 트래픽 집중)  
  - Cross-shard Join 어려움 → De-normalization 필요  

---

## 5. Load Balancer & Auto Scaling

- 서버 확장 시 필수적인 **트래픽 분산 장치**  
- 구조:  
  - Public IP → Load Balancer → Private IP (서버)  
- **VPC 내부**에 LB와 서버 배치  
- **Auto Scaling Group**: 예) CPU 90% 이상 시 서버 자동 증설  

---

## 6. Database Replication

- 구조: **1 Master + N Slave(Replica)**  
- 쓰기 → Master, 읽기 → Replica  
- **Replica Lag(복제 지연)** 문제 발생 가능  
  - 중요 작업: 캐싱으로 보완  
  - 비중요 작업: Eventual Consistency 허용  

🔗 [Handling Failure and Replication Lag - Medium](https://medium.com/@deep.kumar2052/handling-failure-and-replication-lag-for-writes-in-master-slave-architecture-a-real-world-example-c84a03389d59)

---

## 7. Cache

웹 서버와 DB 사이에 **캐시 계층**을 둡니다.

- 자주 읽는 데이터/API → 캐시에 저장  
- 고려사항
  - Write 많은 데이터는 캐시에 부적합  
  - **만료 정책(Expiration Policy)** 필요  
  - DB와 캐시 불일치 → Staleness 이슈  
  - SPOF 방지를 위한 **캐시 클러스터링**  

---

## 8. CDN (Content Delivery Network)

- 정적 파일(JS, 이미지, 비디오)을 **지리적으로 가까운 위치**에서 제공  
- 응답 속도: 보통 20ms 이내가 목표  

동작 흐름:  
1. 유저가 가까운 CDN 노드로 요청  
2. 캐시 히트 시 → 바로 응답  
3. 캐시 미스 시 → Origin 서버에서 가져와 캐싱  

고려사항:  
- 비용 관리 (어떤 파일을 넣을지)  
- 캐시 만료 정책  
- 장애 대비 (CDN도 서비스이므로 항상 안전하지 않음)  
- Invalidation API로 커스텀 제어 가능  


---

## 9. Stateless Web Tier

### Stateful Server
- 세션/파일을 웹 서버 로컬에 저장  
- Scale Out 시 세션 없는 서버에 붙으면 데이터 유실  

### Stateless Server
- 세션/파일은 외부 저장소(DB, Redis, S3 등)에 저장  
- 웹 서버는 요청만 처리 → Scale Out 시 문제 없음  


